[
 "function random(low,high) {\n         return Math.random() * (high - low) + low;\n     }",
 "function randomInt(low,high) {\n         return Math.floor(Math.random() * (high - low) + low);\n     }",
 "function pruneWorktree() {\n         // TO DO: where in the code are the worktrees counted or checked   \n         // update the worktree list, if any worktrees had been removed by user, make sure they aren't\n         // still tracked by git\n         exec(\"git worktree prune\", {cwd: project_path}, () => {\n             // delete work tree (if it exists):\n             if (fs.existsSync(worktreepath)) {\n                 fs.unlinkSync(worktreepath);\n             }\n         })\n     }",
 "function project_build() {\n         let out = \"\";\n         if (process.platform == \"win32\") {\n             out = execSync('build.bat \"'+server_path+'\"', { stdio:'inherit'});\n         } else {\n             out = execSync('sh build.sh \"'+server_path+'\"', { stdio:'inherit'});\n         }\n         console.log(\"built project\", out.toString());\n     }",
 "function git_add_and_commit() {\n         try {\n                     \n             execSync('git add .', {cwd: project_path }, () => {console.log(\"git added\")});\n             execSync('git commit -m \\\"' + commitMsg + '\\\"', {cwd: project_path }, () => {console.log(\"git committed\")});\n             execSync('git status', {cwd: project_path }, (stdout) => {console.log(\"\\n\\n\\n\\n\\n\\n\\n\" + stdout)});\n     \n             // execSync(\"git log --pretty=format:'{%n “%H”: \\\"%aN <%aE>\\\", \\\"%ad\\\", \\\"%f\\\"%n},' $@ | perl -pe 'BEGIN{print \\\"[\\\"}; END{print \\\"]\\n\\\"}' | perl -pe \\'s/},]/}]/\\' > \" + path.join(client_path, \"gitlog.json\"), {cwd: server_path}, () => {\n             // \tconsole.log(\"updated ../client/gitlog.json\")\n             // })\n     \n             //send_all_clients(\"updateRepo?\");\n     \n             //exec('git rev-list --all --parents --timestamp -- test/sim.cpp > times.txt')\n         } catch (e) {\n             console.error(e.toString());\n         }\n     }",
 "function alice_command(command,arg) {\n         let msg = command + \"?\" + arg + \"\\0\";\n         console.log(\"sending alice\", msg);\n         alice.stdin.write(command + \"?\" + arg + \"\\0\");\n     }",
 "function send_all_clients(msg) {\n         wss.clients.forEach(function each(client) {\n            client.send(msg);\n         });\n     }",
 "function make_graph_from_gitlog(gitlog) {\n                         // this will collect an object for each commit:\n                         let commits = [];\n                         // this will collect the names of commits with no parent:\n                         let roots = [];\n                         // the biggest column used so far\n                         // this is used to compute a commit's column position  \n                         let maxcolumn = 1;\n                         // build a lookup-table from hash name to commit object:\n                         let commit_map = {};\n                         // keep a cache of what child names have been mentioned so far\n                         // (this will identify any \"root\" commits)\n                         let forward_refs = {};\t\t\t\t\t\t\t\n                         // pull out each line of the source log:\n                         let lines = gitlog.split(\")\\n\");\n                         for (let i = 0; i < lines.length; i++) {\n                         // get each bar-separated term of the line in an array\n                         let line = lines[i].split(\"|\");\n                         // the first item is the hash commit\n                         let hash = line[0];\n                         if (hash.length) { // skip empty lines\n                             // create an object representation of the commit\n                             let commit = {\n                                 hash: hash,\n                                 // an array of hashes of this commit's children\n                                 children: line[1] ? line[1].split(\" \") : [],\n                                 // an array of terms of the commit's refs\n                                 ref: line[2] ? line[2].split(\", \") : [],\n                                 // the row is determined by the line number\n                                 row: i + 1,\n                                 // the column is initially undetermined (it will be changed later)\n                                 col: 0,\n                                 \n     \n                                 //TODO: add these in. for now they are causing half the commits in the \n                                 //log to be ignored \n                                 \n                                 // the date the commit was made\n                                 commit_date: line[3] ? line[3].split(\", \") : [],\n                                 //who made the commit?\n                                 committer_name: line[4] ? line[4].split(\", \") : [],\n                                 //commit's message\n                                 commit_msg: line[5] ? line[5].split(\", \") : [],\n                                 //list the files and change stats associated with each commit\n                                 commit_files: line[6] ? line.slice(6) : []\n                             };\n                             // if this commit hasn't been encountered as a child yet,\n                             // it must have no parent in the graph:\n                             if (!forward_refs[hash]) {\n                                 roots.push(hash);\n                                 // mark this commit as parent-less\n                                 // not sure if this is really needed\n                                 commit.root = true; \n                             }\n                             \n                             // add to the list of commits\n                             commits.push(commit);\n                             // add to the reverse-lookup by name\n                             commit_map[hash] = commit;\n                             \n                             // also note the forward-referencing of each child\n                             // (so we can know if a future commit has a parent or not)\n                             for (let c of commit.children) {\n                                 forward_refs[c] = true;\n                                 }\n                             }\n                         }\n                     \n                         // depth first traversal\n                         // to assign columns to each commit\n                         // and also generate the paths as we go\n                         \n                         // we'll start with a list of all the commits without parents:\n                         // (using a map() to convert hash names into the full object references)\n                         let stack = roots.map(function(hash) { return commit_map[hash]; }).reverse();\n                         // we need a cache to remember which items we have visited\n                         let visited = {};\n                         \n                         // the result will populate a list of objects representing the paths between commits:\n                         let paths = [];\n                     \n                         // consume each item on our \"todo\" stack, until there are none left:\n                         while (stack.length > 0) {\n                         // remove top item from stack\n                         let commit = stack.pop();\n                         // note that we have now visited this\n                         // (so we don't process a commit twice by mistake)\n                         visited[commit.hash] = true;\n                     \n                         // if the commit doesn't have a column assigned yet, it must be a root\n                         if (!commit.col) {\n                             // create a new empty column for it:\n                             commit.col = maxcolumn++;\n                         } else {\n                             // make sure we have widened our maxcolumn to accommodate this commit\n                             maxcolumn = Math.max(maxcolumn, commit.col);\n                         }\n                     \n                         // for each child:\n                         for (let i = commit.children.length - 1; i >= 0; i--) {\n                             let child_hash = commit.children[i];\n                             // get the actual child object this hash refers to\n                             let child = commit_map[commit.children[i]];\n                             if (child) { // skip if the child commit is not in our source\n                             // if we haven't visited this child yet, \n                             if (!visited[child_hash]) {\n                                 // assign it a new column, relative to parent\n                                 child.col = commit.col + i;\n                                 // and add it to our \"todo\" stack:\n                                 stack.push(child);\n                             }\n                             // add an object representation of this path:\n                             paths.push({\n                                 from: commit.hash,\n                                 to: child.hash\n                             });\n                             }\n                         }\n                         }\n                         // return a full representation of the graph:\n                         return {\n                         maxcolumn: maxcolumn,\n                         roots: roots,\n                         commits: commits,\n                         paths: paths\n                         };\n                     }",
 "function make_graph_from_gitlog(gitlog) {\n                         // this will collect an object for each commit:\n                         let commits = [];\n                         // this will collect the names of commits with no parent:\n                         let roots = [];\n                         // the biggest column used so far\n                         // this is used to compute a commit's column position  \n                         let maxcolumn = 1;\n                         // build a lookup-table from hash name to commit object:\n                         let commit_map = {};\n                         // keep a cache of what child names have been mentioned so far\n                         // (this will identify any \"root\" commits)\n                         let forward_refs = {};\t\t\t\t\t\t\t\n                         // pull out each line of the source log:\n                         let lines = gitlog.split(\")\\n\");\n                         for (let i = 0; i < lines.length; i++) {\n                         // get each bar-separated term of the line in an array\n                         let line = lines[i].split(\"|\");\n                         // the first item is the hash commit\n                         let hash = line[0];\n                         if (hash.length) { // skip empty lines\n                             // create an object representation of the commit\n                             let commit = {\n                                 hash: hash,\n                                 // an array of hashes of this commit's children\n                                 children: line[1] ? line[1].split(\" \") : [],\n                                 // an array of terms of the commit's refs\n                                 ref: line[2] ? line[2].split(\", \") : [],\n                                 // the row is determined by the line number\n                                 row: i + 1,\n                                 // the column is initially undetermined (it will be changed later)\n                                 col: 0,\n                                 \n     \n                                 //TODO: add these in. for now they are causing half the commits in the \n                                 //log to be ignored \n                                 \n                                 // the date the commit was made\n                                 commit_date: line[3] ? line[3].split(\", \") : [],\n                                 //who made the commit?\n                                 committer_name: line[4] ? line[4].split(\", \") : [],\n                                 //commit's message\n                                 commit_msg: line[5] ? line[5].split(\", \") : [],\n                                 //list the files and change stats associated with each commit\n                                 commit_files: line[6] ? line.slice(6) : []\n                             };\n                             // if this commit hasn't been encountered as a child yet,\n                             // it must have no parent in the graph:\n                             if (!forward_refs[hash]) {\n                                 roots.push(hash);\n                                 // mark this commit as parent-less\n                                 // not sure if this is really needed\n                                 commit.root = true; \n                             }\n                             \n                             // add to the list of commits\n                             commits.push(commit);\n                             // add to the reverse-lookup by name\n                             commit_map[hash] = commit;\n                             \n                             // also note the forward-referencing of each child\n                             // (so we can know if a future commit has a parent or not)\n                             for (let c of commit.children) {\n                                 forward_refs[c] = true;\n                                 }\n                             }\n                         }\n                     \n                         // depth first traversal\n                         // to assign columns to each commit\n                         // and also generate the paths as we go\n                         \n                         // we'll start with a list of all the commits without parents:\n                         // (using a map() to convert hash names into the full object references)\n                         let stack = roots.map(function(hash) { return commit_map[hash]; }).reverse();\n                         // we need a cache to remember which items we have visited\n                         let visited = {};\n                         \n                         // the result will populate a list of objects representing the paths between commits:\n                         let paths = [];\n                     \n                         // consume each item on our \"todo\" stack, until there are none left:\n                         while (stack.length > 0) {\n                         // remove top item from stack\n                         let commit = stack.pop();\n                         // note that we have now visited this\n                         // (so we don't process a commit twice by mistake)\n                         visited[commit.hash] = true;\n                     \n                         // if the commit doesn't have a column assigned yet, it must be a root\n                         if (!commit.col) {\n                             // create a new empty column for it:\n                             commit.col = maxcolumn++;\n                         } else {\n                             // make sure we have widened our maxcolumn to accommodate this commit\n                             maxcolumn = Math.max(maxcolumn, commit.col);\n                         }\n                     \n                         // for each child:\n                         for (let i = commit.children.length - 1; i >= 0; i--) {\n                             let child_hash = commit.children[i];\n                             // get the actual child object this hash refers to\n                             let child = commit_map[commit.children[i]];\n                             if (child) { // skip if the child commit is not in our source\n                             // if we haven't visited this child yet, \n                             if (!visited[child_hash]) {\n                                 // assign it a new column, relative to parent\n                                 child.col = commit.col + i;\n                                 // and add it to our \"todo\" stack:\n                                 stack.push(child);\n                             }\n                             // add an object representation of this path:\n                             paths.push({\n                                 from: commit.hash,\n                                 to: child.hash\n                             });\n                             }\n                         }\n                         }\n                         // return a full representation of the graph:\n                         return {\n                         maxcolumn: maxcolumn,\n                         roots: roots,\n                         commits: commits,\n                         paths: paths\n                         };\n                     }",
 "function loadsim() {\n         // TODO: find a better way to IPC commands:\n         alice_command(\"openlib\", projectlib);\n         \n     }",
 "function unloadsim() {\n         // TODO: find a better way to IPC commands:\n         alice_command(\"closelib\", projectlib);\n     }",
 "function codeForensics() {\n         if (process.argv[3] == \"--forensics\") {\n         exec('gulp webserver', {cwd: __dirname});\n         }\n     }"
]