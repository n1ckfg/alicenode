<!doctype html>

<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1">
<title>Deck of Cards ide</title>

<head>
<!-- //TEMPORARY: just to aid in development workflow -->
<meta http-equiv="refresh" content="5; URL=http://localhost:8080">
<!--        SOURCES         -->
<!-- Codemirror -->
    <!-- styles -->

    <link rel=stylesheet href="cm/docs.css">
    <link rel=stylesheet href="cm/codemirror.css">
    <link rel=stylesheet href="cm/addons/fullscreen/fullscreen.css">

    <!-- <link rel=stylesheet href="cm/merge.css">
    <link rel=stylesheet href="cm/icecoder.css"> -->

    <!-- scripts -->
    <script src="cm/codemirror.js"></script>
    <script src="cm/css.js"></script>
    <!-- load local server version if cdn unavailable -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script><script>if (!window.jQuery) document.write('<script src="cm/diff_match_patch.js"><\/script>');</script>

    <!-- <script src="cm/htmlmixed.js"></script> -->
    <!-- <script src="cm/xml.js"></script> -->
    <!-- <script src="cm/merge.js"></script> -->
    <!-- <script src="cm/modes/javascript.js"></script> -->
    <script src="cm/modes/clike.js"></script>
    <script src="cm/modes/glsl.js"></script>
      <script src="cm/addons/buttons/buttons.js"></script>
  <script src="cm/addons/panel.js"></script>
  <script src="cm/addons/fullscreen/fullscreen.js"></script>





<!-- General Sources -->
    <!-- style -->
    <link rel=stylesheet href="css/jquery-ui.css">
    <link rel=stylesheet href="css/alicenode.css">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">


    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <script>if (!window.jQuery) document.write('<script src="cm/diff_match_patch.js"><\/script>');</script>


    <!-- server address & open/close -->

</head>

<!-- Important: must have a body section so that the 'double click = new card' UI works -->
<body ondblclick="doubleClick(event);">




    <table width="100%">
        <tr height="30px" bgcolor="#daeef4">
            <th style="text-decoration: none">Deck of Cards ide</th>
            <th><input id="server" type="text" value="ws://localhost:8080" size="40">
                <button onclick="openSocket()">Open</button>
                <button onclick="closeSocket()">Close</button></th>
        </tr>
        
    </table>
    <!--container for all cards  -->
    <div class="deck">


</body>

<script>
    
var cardIdArray = []; //store the list of card ID names
var value = "//new card" //default contents of a new card. can be replaced by a code fragment from the server

var count = 1; //count the number of cards generated, start at 1
var cardId = 1; //id for each new card div created

var bodySize = [document.body.clientWidth, document.body.clientHeight]
var ws_url;
var worktreeList;
var history;
var ws;
var ws_url = "ws://" + window.location.host;

function log(msg){
  console.log(msg)
}


//double-click anywhere on html body to create a blank new card
function doubleClick(e) {
    if (e.target.nodeName == "BODY"){
        // generate new card at current mouse x and y position
        
        var x = (e.pageX)
        var y = (e.pageY - 30) //to compensate for the header bar in the main page. update this number if anything else gets added to top or left of page. 
        newCard(x, y); 
    }
}
$( "div, p" ).disableSelection();







// code cards:
//this card holds the file name, and info about the file
// function deckMeta(filename, ast){

//     // var instance = count ++;
//     frameId = ("frame_" + filename);

//     cardId = ("card_" + filename);
//     cardIdArray.push(cardId)
//     value = (ast + "\n" + filename)
            
//     // create a frame place it at the mouse position, and insert the code card within
//     // var $item = $('<div class="actve" width=300px height=340px style="position: absolute; left: ' + x + '; top: ' + y + ' id="' + frameId + '"<h2>' + cardId + '</h2>').append('<div class="card" id="' + cardId + '"/>')
//         // var $item = $('<table width=300px style="position: absolute; margin-left:' + x + 'px; margin-top:' + y + 'px; id="' + frameId + '"> <tr bgcolor="#eec239" > <th> <h3 style="color:#112b36;" text-decoration="none">' + cardId + '</h3></th></tr> <tr><td><div class="card" id="' + cardId + '"</td></tr></table>')
//     var $item = $('<table width=300px style="position: absolute; margin-left:' + 40 + 'px; margin-top:' + 40 + 'px; id="' + frameId + '"> <tr bgcolor="#eec239" height=10px> <th></th></tr><tr ><td><form class="card"> <input  type="text" name="' + cardId + '_title" value="' + ast + ' ' + filename + '"></form></th></tr> <tr><td><div class="card" id="' + cardId + '"</div></td></tr></table>')
//                // <h3 style="color:#112b36;" text-decoration="none">' + cardId + '</h3></
 
 
//     // make it draggable, prevent the code from being dragged(need to select text) and auto-reorder the cards based on last-clicked (stack)
//     $item.draggable({ cancel: "div.card", cancel: "form.card", stack: cardId + " div" }); 
//         //difficult to get accordion working with codemirror, comes out weird
//         // $item.accordion({collapsible: true, heightStyle: "content"});   

//     // add it to the deck
//     $item.appendTo('.deck');

//     initUI();   
//     $( function() {
//         $( cardId )
//     });  

// }
//create a blank new card, add to the deck
function newCard(x, y){
    var instance = count ++;
    frameId = ("frame_" + instance);

    cardId = ("card_" + instance);
    cardIdArray.push(cardId)
            
    // create a frame place it at the mouse position, and insert the code card within
    // var $item = $('<div class="actve" width=300px height=340px style="position: absolute; left: ' + x + '; top: ' + y + ' id="' + frameId + '"<h2>' + cardId + '</h2>').append('<div class="card" id="' + cardId + '"/>')
        // var $item = $('<table width=300px style="position: absolute; margin-left:' + x + 'px; margin-top:' + y + 'px; id="' + frameId + '"> <tr bgcolor="#eec239" > <th> <h3 style="color:#112b36;" text-decoration="none">' + cardId + '</h3></th></tr> <tr><td><div class="card" id="' + cardId + '"</td></tr></table>')
            var $item = $('<table width=300px style="position: absolute; margin-left:' + x + 'px; margin-top:' + y + 'px; id="' + frameId + '"> <tr bgcolor="#eec239" height=10px> <th></th></tr><tr ><td><form class="card"> <input  type="text" name="' + cardId + '_title" value="' + cardId + '"></form></td></tr> <tr><td><div class="card" id="' + cardId + '"</div></td></tr></table>')
               // <h3 style="color:#112b36;" text-decoration="none">' + cardId + '</h3></
 
 
    // make it draggable, prevent the code from being dragged(need to select text) and auto-reorder the cards based on last-clicked (stack)
    $item.draggable({ cancel: "div.card", cancel: "form.card", stack: cardId + " div" }); 
        //difficult to get accordion working with codemirror, comes out weird
        // $item.accordion({collapsible: true, heightStyle: "content"});   

    // add it to the deck
    $item.appendTo('.deck');
    value = ("//new card")

    initUI(value, cardId, cardId);   
    $( function() {
        $( cardId )
    });  
   
}

/*
//create a deck of cards received from server:
function sortDeck(x, y, ast, card, name){
    var instance = count ++;
    frameId = ("frame_" + instance);

    cardId = ("card_" + instance);
    cardIdArray.push(cardId)
    value = ("//new card")
            
    // create a frame place it at the mouse position, and insert the code card within
    // var $item = $('<div class="actve" width=300px height=340px style="position: absolute; left: ' + x + '; top: ' + y + ' id="' + frameId + '"<h2>' + cardId + '</h2>').append('<div class="card" id="' + cardId + '"/>')
        // var $item = $('<table width=300px style="position: absolute; margin-left:' + x + 'px; margin-top:' + y + 'px; id="' + frameId + '"> <tr bgcolor="#eec239" > <th> <h3 style="color:#112b36;" text-decoration="none">' + cardId + '</h3></th></tr> <tr><td><div class="card" id="' + cardId + '"</td></tr></table>')
    var $item = $('<table width=300px style="position: absolute; margin-left:' + x + 'px; margin-top:' + y + 'px; id="' + frameId + '"> <tr bgcolor="#eec239" height=10px> <th></th></tr><tr ><td><form class="card"> <input  type="text" name="' + cardId + '_title" value="' + ast + ' ' + name + '"></form></th></tr> <tr><td><div class="card" id="' + cardId + '"</div></td></tr></table>')
               // <h3 style="color:#112b36;" text-decoration="none">' + cardId + '</h3></
 
 
    // make it draggable, prevent the code from being dragged(need to select text) and auto-reorder the cards based on last-clicked (stack)
    $item.draggable({ cancel: "div.card", cancel: "form.card", stack: cardId + " div" }); 
        //difficult to get accordion working with codemirror, comes out weird
        // $item.accordion({collapsible: true, heightStyle: "content"});   
    $item.tabs({ collapsible: true, event: "mouseover"})
    // add it to the deck
    $item.appendTo('.deck');

    initUI(card, (ast + '_' + name), cardId);   
    $( function() {
        $( cardId )
    });  
   
} */




//get and set code in the new card
function initUI(comment, name, cardId) {
   // isRightDirty = false;
    if (value == null) return;

    var target = document.getElementById(cardId);
    target.innerHTML = "";
    dv = CodeMirror(target, {
        value: comment,
        // origLeft: panes == 3 ? orig1 : null,
        // origRight: orig1,
        lineNumbers: true,
        mode: "clike",
        //highlightDifferences: "highlight",
        
        //NOTE: viewportMargin, when set to 'infinity', allows for full text searching, BUT when set to a high number seems to have been the source of the sluggishness in the client app!! so now its only at 10. 
        viewportMargin: 10,
        revertButtons: true,
        allowEditingOriginals: true,
        // autoRefresh: true,
        // showDifferences: true,
        linewrapping: true,
        // addPanel: cardId
        // connect: "connect",
        // theme: "icecode",
        // collapseIdentical: true,
        // collapse: collapse
        
        // fullscreen: true,
        /* init: */
        //place cursor in left editor at client init
        autofocus: 1,
        

        //editing
        undoDepth: 200,


        //cursor settings:
        cursorBlinkRate: 300,
        cursorScrollMargin: 0,
        
        //eventually change these buttons to minimize, mute, fullscreen, etc. 
        buttons: [
        {   //minimize
            hotkey: 'Ctrl-M',
            label: '--',
            callback: function (cm) {

                // $(cardId).hide();
                
                // $("#show").click(function(){
                //     $("p").show();
                // });
                
            }
        },
        {
            hotkey: 'Ctrl-F',
            label: 'F',
            callback: function (cm) {
                cm.setOption("fullScreen", !cm.getOption("fullScreen"));
                document.title = name;
            }



        },
        // {
        //     hotkey: 'Ctrl-B',
        //     class: 'bold',
        //     label: '<strong>B</strong>',
        //     callback: function (cm) {
        //         var selection = cm.getSelection();
        //         cm.replaceSelection('**' + selection + '**');
        //         if (!selection) {
        //             var cursorPos = cm.getCursor();
        //             cm.setCursor(cursorPos.line, cursorPos.ch - 2);
        //         }
        //     }
        // },
        // {
        //     hotkey: 'Ctrl-I',
        //     class: 'italic',
        //     label: '<i>I</i>',
        //     callback: function (cm) {
        //         var selection = cm.getSelection();
        //         cm.replaceSelection('*' + selection + '*');
        //         if (!selection) {
        //             var cursorPos = cm.getCursor();
        //             cm.setCursor(cursorPos.line, cursorPos.ch - 1);
        //         }
        //     }
        // },
        // {
        //     class: 'inline-code',
        //     label: 'code',
        //     callback: function (cm) {
        //         var selection = cm.getSelection();
        //         cm.replaceSelection("`" + selection + "`");
        //         if (!selection) {
        //             var cursorPos = cm.getCursor();
        //             cm.setCursor(cursorPos.line, cursorPos.ch - 1);
        //         }
        //     }
        // },
        // {
        //     class: 'block-php',
        //     label: '&lt;php&gt;',
        //     callback: function (cm) {
        //         var selection = cm.getSelection();
        //         cm.replaceSelection("```php\n<?php\n" + selection + "\n```\n");
        //         if (!selection) {
        //             var cursorPos = cm.getCursor();
        //             cm.setCursor(cursorPos.line - 2, 0);
        //         }
        //     }
        // },
        // {
        //     class: 'block-code',
        //     label: '&lt;-&gt;',
        //     callback: function (cm) {
        //         var selection = cm.getSelection();
        //         cm.replaceSelection("```\n" + selection + "\n```\n");
        //         if (!selection) {
        //             var cursorPos = cm.getCursor();
        //             cm.setCursor(cursorPos.line - 2, 0);
        //         }
        //     }
        // },
        // {
        //     class: 'quote',
        //     label: '>',
        //     callback: function (cm) {
        //         cm.replaceSelection("> " + cm.getSelection());
        //     }
        // },
        // {
        //     class: 'ul',
        //     label: 'ul',
        //     callback: function (cm) {
        //         cm.replaceSelection("- " + cm.getSelection());
        //     }
        // },
        // {
        //     class: 'ol',
        //     label: 'ol',
        //     callback: function (cm) {
        //         cm.replaceSelection("1. " + cm.getSelection());
        //     }
        // },
        // {
        //     class: 'a',
        //     label: 'a',
        //     callback: function (cm) {
        //         var selection = cm.getSelection();
        //         var text = '';
        //         var link = '';

        //         if (selection.match(/^https?:\/\//)) {
        //             link = selection;
        //         } else {
        //             text = selection;
        //         }
        //         cm.replaceSelection('[' + text + '](' + link + ')');

        //         var cursorPos = cm.getCursor();
        //         if (!selection) {
        //             cm.setCursor(cursorPos.line, cursorPos.ch - 3);
        //         } else if (link) {
        //             cm.setCursor(cursorPos.line, cursorPos.ch - (3 + link.length));
        //         } else {
        //             cm.setCursor(cursorPos.line, cursorPos.ch - 1);
        //         }
        //     }
        // }
    ],

    });
}

//codemirror interaction:

// $(document).keyup(function(e) {
//      if (e.keyCode == 27) { // escape key maps to keycode `27`
//         // <DO YOUR WORK HERE>
//         cm.setOption("fullScreen", !cm.getOption("fullScreen"));
//         document.title = "Deck of Cards ide";
//     }
// });


document.getElementById('server').value = ws_url;

function openSocket() {
    log('opening');
    var url = document.getElementById('server').value;
    ws = new WebSocket(ws_url);
    ws.binaryType = 'arraybuffer';
    ws.onopen = function() {
        // log('open');  
        // ws.send("client_SVG?")

        // ws.send("getCurrentBranch")
        
        // //temporary: for now set user as Guest so I don't have to keep choosing user while developing. 
        // ws.send("selectUser?" + "Guest");
        
        sessionStorage.echoServer = url;
    };
    ws.onclose = function() {
        // log('close');
    };
    ws.onmessage = function(e) {
        /*if (e.data instanceof Blob) {
            var reader = new FileReader();
            reader.onload = function(e) {
                log('received blob: ' + encodeHexString(new Uint8Array(e.target.result)));
            };
            reader.readAsArrayBuffer(e.data);
        } else */
        if (e.data instanceof ArrayBuffer) {
            //log(encodeHexString(new Uint8Array(e.data)));
            //log("received arraybuffer size: " + e.data.byteLength + " bytes");
            
            let s = "";
            let fv = new Float32Array(e.data);
            for (var i = 0; i < fv.length; i+=3) {
                s += "<li>" + (i/3 + ": { " + fv[i] + ", " + fv[i+1] + ", " + fv[i+2] + " }</li>");
            }
            
            // document.getElementById('state').innerHTML = s;     
            
        } else {
            let message = e.data;
            let q = message.indexOf("?");
            if (q > 0) {
                let cmd = message.substring(0, q);
                let arg = message.substring(q+1);
                switch(cmd) {
                    
                    case "deck":
                    //console.log(arg)
                    deck = (JSON.parse(arg))
                    //var newCard = [];

                    //var numCards = 0;



                    function visit(node, parentnode, ctx) {
                        //console.log("enter", node.ast, "of", parentnode ? parentnode.ast : node.filename);

                        //ctx.card.push(node.ast);
                        // if (node.comment.text){
                        //   //  ctx.card.push(node.comment.text)
                       
                        var card = {}
                        // }
                        let ctx1 = {
                            card: [],
                        }

                        // add more props depending on the node type

                        //first check if a node has children, if not, ignore. 
                        if (node.nodes){
                            if (node.ast == "TranslationUnit"){
                                //establish TU as top of hierarchy for this deck
                                ctx.card.push(node.filename);

                                /* //this may or may not be necessary... hopefully not, hopefully we can just use pass the completed 'ctx' to a graph library and generate the entire 'patcher' 
                                var children = [];

                                Object.keys(deck.nodes).forEach(function(key) {

                                    children.push(deck.nodes[key].name)

                                })
                                sortDeck(100, 100, node.ast, children.toString(), node.filename)
                                */
                            }
                            //console.log(node.ast)
                            if (node.ast == "StructDecl"){
                                var children = [];

                                Object.keys(node.nodes).forEach(function(key) {
                                    //if a child has a mangled name, get it
                                    if (node.nodes[key].mangled_name) {
                                        children.push(node.nodes[key].mangled_name)

                                    } else {
                                        //some types don't have a mangled name, so just get its name
                                        children.push(node.nodes[key].name)
                                    }

                                });  
                                console.log(children)

                                
                                if (node.comment){
                                // ctx.card.push(node.comment.text)
                                }   
                                ctx.card.push(node.comment.text + "struct " + node.name + "{")

                                sortDeck(300, 200, node.ast, (node.comment.text + "struct " + node.name + "{"), node.name)
                                //console.log(node.ast + " true")
                            }

                            
                            // do this for structs, tranlation units, 
                            // but not for functions
                            for (c of node.nodes) {
                                //console.log(node.nodes)
                                visit(c, node, ctx1);
                            }
                            //console.log("exit", node.ast);

                            ctx.card.push(ctx1);
                            //ctx.card.push("</div>")
                        }
                    }

                    let ctx = {
                        card: [],
                    }

                    visit(deck, null, ctx);

                    console.log(JSON.stringify(ctx, null, 3));

                    //create a deck of cards received from server:
                    function sortDeck(x, y, ast, card, name, children){
                        var instance = count ++;
                        frameId = ("frame_" + instance);

                        cardId = ("card_" + instance);
                        cardIdArray.push(cardId)
                        value = ("//new card")
                                
                        // create a frame place it at the mouse position, and insert the code card within
                        // var $item = $('<div class="actve" width=300px height=340px style="position: absolute; left: ' + x + '; top: ' + y + ' id="' + frameId + '"<h2>' + cardId + '</h2>').append('<div class="card" id="' + cardId + '"/>')
                            // var $item = $('<table width=300px style="position: absolute; margin-left:' + x + 'px; margin-top:' + y + 'px; id="' + frameId + '"> <tr bgcolor="#eec239" > <th> <h3 style="color:#112b36;" text-decoration="none">' + cardId + '</h3></th></tr> <tr><td><div class="card" id="' + cardId + '"</td></tr></table>')
                        var $item = $('<table width=300px style="position: absolute; margin-left:' + x + 'px; margin-top:' + y + 'px; id="' + frameId + '"> <tr bgcolor="#eec239" height=10px> <th></th></tr><tr ><td><form class="card"> <input  type="text" name="' + cardId + '_title" value="' + ast + ' ' + name + '"></form></th></tr> <tr><td><div class="card" id="' + cardId + '"</div></td></tr></table>')
                                // <h3 style="color:#112b36;" text-decoration="none">' + cardId + '</h3></
                    
                    
                        // make it draggable, prevent the code from being dragged(need to select text) and auto-reorder the cards based on last-clicked (stack)
                        $item.draggable({ cancel: "div.card", cancel: "form.card", stack: cardId + " div" }); 
                            //difficult to get accordion working with codemirror, comes out weird
                            // $item.accordion({collapsible: true, heightStyle: "content"});   
                        $item.tabs({ collapsible: true, event: "mouseover"})
                        // add it to the deck
                        $item.appendTo('.deck');

                        initUI(card, (ast + '_' + name), cardId);   
                        $( function() {
                            $( cardId )
                        });  
                    
                    }
                    //console.log(deck.nodes)
                    
                    // Object.keys(deck.nodes).forEach(function(key) {
                    //     //for now, generate random positions for each card of the received deck
                    //     function newInt(max) {
                    //         return Math.floor(Math.random() * Math.floor(max));
                    //     }
                    //     numCards++;
                    //     cardX = newInt(bodySize[0])
                    //     cardY = newInt(bodySize[1])

                    //     var ast = deck.nodes[key].ast //get the ast type
                    //     comment = deck.nodes[key].comment.text //get comment from function
                    //     mangled = deck.nodes[key].mangled_name
                    //     //todo how to use loc?
                    //     var name = deck.nodes[key].name
                    //     var nodes = deck.nodes[key].nodes
                        
                    //     //construct the contents of the card:
                    //     type = deck.nodes[key].type
                    //     func = type.replace(" ", " " + name)
                    //     func = func.replace(")", " " + deck.nodes[key].nodes[0].name + ") {\n   return x;\n}")
                    //     //console.log(comment + "\n" + func)
                    //     card = comment + "\n" + func

                    //     sortDeck(cardX, cardY, ast, card, name)

                    // })
                        //define the name of the deck
                        // var deckFile = deck.filename;

                        // Object.keys(deck.nodes).forEach(function(key) {
                        // //for now, generate random positions for each card of the received deck
                        // function newInt(max) {
                        //     return Math.floor(Math.random() * Math.floor(max));
                        // }
                        // numCards++;
                        // cardX = newInt(bodySize[0])
                        // cardY = newInt(bodySize[1])

                        // var ast = deck.nodes[key].ast //get the ast type
                        // var name = deck.nodes[key].name
                        // var comment = deck.nodes[key].comment.text

                        // if (ast == "StructDecl") {
                        //     struct = "struct " + name + "{\n}"
                            
                        //     Object.keys(deck.nodes[key].nodes).forEach(function(key) {
                        //         //console.log(key)
                        //         console.log(deck.nodes[key].nodes[key].ast)
                        //     });
                            
                            
                        //     console.log(comment + "\n" + struct)
                        // }

                        // if (ast == "FunctionDecl") {
                        
                        // }
                        //console.log("test")
                        // comment = deck.nodes[key].comment.text //get comment from function
                        // mangled = deck.nodes[key].mangled_name
                        // //todo how to use loc?
                        // var name = deck.nodes[key].name
                        // var nodes = deck.nodes[key].nodes
                        
                        // //construct the contents of the card:
                        // type = deck.nodes[key].type
                        // func = type.replace(" ", " " + name)
                        // func = func.replace(")", " " + deck.nodes[key].nodes[0].name + ") {\n   return x;\n}")
                        // //console.log(comment + "\n" + func)
                        // card = comment + "\n" + func

                        // sortDeck(cardX, cardY, ast, card, name)

                    //})
                    break;
                    default:
                        log("cmd: " + cmd + ", " + arg);
                    }
        
                } else {
            
                log('received: ' + e.data);
                }
            }
        };
    ws.onerror = function() {
        log('error');
    };
}

function closeSocket() {
    log('closing');
    ws.close();
}

// keep checking socket status, re-open if closed:
setInterval(function(){
        if (!ws || ws.readyState === WebSocket.CLOSED) openSocket();
}, 2000);


</script>


