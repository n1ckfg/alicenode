<!doctype html>

<title>Alicenode: Client</title>
<meta charset="utf-8"/>

<!--        SOURCES         -->
<!-- Codemirror -->
    <!-- styles -->
    <link rel=stylesheet href="cm/docs.css">
    <link rel=stylesheet href="cm/codemirror.css">
    <link rel=stylesheet href="cm/merge.css">
    <link rel=stylesheet href="cm/icecoder.css">

    <!-- scripts -->
    <script src="cm/codemirror.js"></script>
    <script src="cm/css.js"></script>
    <!-- load local server version if cdn unavailable -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script><script>if (!window.jQuery) document.write('<script src="cm/diff_match_patch.js"><\/script>');</script>

    <script src="cm/htmlmixed.js"></script>
    <script src="cm/xml.js"></script>
    <script src="cm/merge.js"></script>
    <script src="cm/modes/javascript.js"></script>
    <script src="cm/modes/clike.js"></script>
    <script src="cm/modes/glsl.js"></script>

<!-- General Sources -->
    <!-- style -->
    <link rel=stylesheet href="css/jquery-ui.css">
    <link rel=stylesheet href="css/alicenode.css">


    <!-- scripts -->
    <script type="text/javascript" src="js/pako.js"></script>
    <!-- <script type="text/javascript" src="js/pako_inflate.js"></script> -->
    <!-- <script type="text/javascript" src="js/pako_deflate.js"></script> -->
    <script src="js/jquery-3.3.1.js"></script>
    <script src="js/jquery-ui.js"></script>
    <script src="js/jquery.mousewheel.min.js"></script>
    <script src="js/jquery.color.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/jquery.graphviz.svg.js"></script>


<!-- temp fix for the 'cannot find 'favicon.ico' error -->
    <link rel="shortcut icon">


<!--        HTML UI Elements        -->

    <!-- server address & open/close -->
    <input id="server" type="text" value="ws://localhost:8080" size="40">
    <button onclick="openSocket()">Open</button>
    <button onclick="closeSocket()">Close</button>
      
<!-- Client 'logs in' to server using the full name and email associated with their github account -->
</form>
<form name="usernames"> Current User: 
    <select id="chooseUser" onchange="userSelect();">
            <option selected disabled>Please Select User</option> 
            <option value="Add User...">Add User...</option>
            <option value="Guest">Guest</option>

    </select> 
       <!-- emailmichaelpalumbo@gmail.com -->
</form>

<!-- Customize the Codemirror Instance -->
Editor Settings
<p></p>

<div class="onoffswitch">
    <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="myonoffswitch" onclick="toggleDifferences()" checked>
    <label class="onoffswitch-label" for="myonoffswitch"></label>
</div>Live Diffing

<br>
<div class="onoffswitch">
    <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="myonoffswitch" onclick="collapse = !collapse; initUI()">
    <label class="onoffswitch-label" for="myonoffswitch"></label>
</div>Collapse Changes

<br>
<div class="onoffswitch">
    <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="myonoffswitch" onclick="connect = connect ? null : 'align'; initUI()">
    <label class="onoffswitch-label" for="myonoffswitch"></label>
</div>Align Changes
<br>

<!-- Send code to server -->
<button onclick="sendLeftCode()">Send Left Code</button>
<button onclick="sendCodeRelay()">Send Right Code</button>

<!-- the Codemirror mergeview instance! -->
<div id="container">
    <div id="view"></div>
    <div id="gitgraph" style="text-align: left; padding-left: 10px"></div>
</div>
<p>

<!-- TODO: mouseover a node puts the commit detail into this heading: -->

<!-- server messages -->
<div id="serverMessages">
    <ul id="messages"></ul>
    <!-- <ul id="commit_detail">Commit Details</h3> -->
</div>



<!-- Client interaction with the git commit nodes -->
<script type="text/ecmascript">

  



           // sendRightCode("hash?" + evt.target.id);
     // }


</script>

<script>

//globals
var currentBranch;
var thisHash;
var selectedCommit;
var currentWorktree
var ws_url;
var worktreeList;
var history;
var ws;
var ws_url = "ws://" + window.location.host;
 //var col;
// codemirror/mergeview globals:
var value;
var orig1;
var dv;
panes = 2;
highlight = true;
connect = "align";
var target;
var collapse;
var requested;
var current;
var isRightDirty = false;
var currentBranch;
var userlist = []; //list of git authors associated with alicenode_inhabitat (from server)
var authorName = "Guest"; //git will make commits under this provided name, will change if client user selects different name
var authorEmail;


     
//send the code from right pane
function sendCodeRelay(){
    sendRightCode("a")
}

document.getElementById('server').value = ws_url;

function openSocket() {
    log('opening');
    var url = document.getElementById('server').value;
    ws = new WebSocket(ws_url);
    ws.binaryType = 'arraybuffer';
    ws.onopen = function() {
        // log('open');  
        ws.send("client_SVG?")

        ws.send("getCurrentBranch")
        
        //temporary: for now set user as Guest so I don't have to keep choosing user while developing. 
        ws.send("selectUser?" + "Guest");

        sessionStorage.echoServer = url;
    };
    ws.onclose = function() {
        // log('close');
    };
    ws.onmessage = function(e) {

        /*if (e.data instanceof Blob) {
            var reader = new FileReader();
            reader.onload = function(e) {
                log('received blob: ' + encodeHexString(new Uint8Array(e.target.result)));
            };
            reader.readAsArrayBuffer(e.data);
        } else */
        if (e.data instanceof ArrayBuffer) {
            //log(encodeHexString(new Uint8Array(e.data)));
            //log("received arraybuffer size: " + e.data.byteLength + " bytes");
            
            let s = "";
            let fv = new Float32Array(e.data);
            for (var i = 0; i < fv.length; i+=3) {
                s += "<li>" + (i/3 + ": { " + fv[i] + ", " + fv[i+1] + ", " + fv[i+2] + " }</li>");
            }
            
            // document.getElementById('state').innerHTML = s;     
            
        } else {
            let message = e.data;
            let q = message.indexOf("?");
            if (q > 0) {
                let cmd = message.substring(0, q);
                let arg = message.substring(q+1);
                switch(cmd) {
                    
                    case "setUserList":
                        
                        userlist = JSON.parse(arg);
                        var sel = document.getElementById('chooseUser');
                        //var length = select;
                            
                        // for (i = 3; i < sel.length; i++) {
                        //     sel.options[i] = null;
                        //     }
                        Object.keys(userlist).forEach(function (key) {
                            var opt = document.createElement('option');
                            opt.appendChild( document.createTextNode(key) );
                            opt.value = key;
                            sel.appendChild(opt);
                        })
                        sel.selectedIndex = 2; 





                            // $("chooseUser").append(
                            // $.map(userlist, function(v,k){

                            //     return $("<option>").val(k).text(v);
                            // })
                            // );

                            // var list = document.getElementById("chooseUser");
                            // for(var i in userlist) {
                            //     console.log(userlist[i])
                            // list.add(new Option(userlist[i].text, userlist[i].value));
                            // }
                        // $.each(arg, function(key, value) {
                        //     $('chooseUser')
                        //         .append($('<option>', { value : key })
                        //             //.attr("value", key)
                        //             .text(value));
                        //})
                    break;
                    ////////////////////////////////////////////////////
                    //svg from server:
                    case "gitLog":
                    //let graph = arg;

                  
                    let graph = JSON.parse(pako.inflate(arg, {to : 'string'}));
                    
                    let svg = make_svg_from_commits(graph);

                    //push the svg content to the gitgraph div
                    $("#gitgraph").html(svg)
                    //make the gitgraph resizeable
                    //see more at https://jqueryui.com/resizable
                    $( function() {
                        $( "#gitgraph" ).resizable();
                    });
                    break;
                        
                    //TODO: unable to iterate through an array's values. for some reason the values get split into separate characters. 
                    case "worktreeList":
                        console.log(arg)
                        //var names = arg
                        //html select element
                        var sel = document.getElementById('userWorktree');
                        //var length = select;
                        
                        //first clear the worktree items from select (so we don't add duplicates)
                        for (i = 1; i < sel.length; i++) {
                            sel.options[i] = null;
                            }
                        // console.log(arg.length)
                        // for (var i = 0, len = arg.length; i < len; i++) {
                        // console.log(arg.[i])
                        // }
                                            //PLO
                        // arg.forEach(function(element) {
                        // console.log("test " + element)
                        // })
                        // console.log(names)
                        
                        // var iterator = arg.values();
                        // for (let letter of iterator) {
                        //     console.log(letter)
                        // }
                        




                            //TODO: got to figure out how to populate the select menu with the 'options' variable:
                            
                        // for (var i = 0; i < sel.options.length; i++) {
                        //     var opt = document.createElement('option');
                        //     opt.innerHTML = options[i];
                        //     opt.value = options[i];
                        //     sel.appendChild(opt);
                        // }


                        // var err = arg.split("\n");
                        // var select = document.getElementById('userWorktree')
                        // select.options[select.options.length] = new  Option('Please Select...', 'Please Select...');
                    

                        //     err.foreach(function(element) {
                        //     var x = document.getElementById("userWorktree");
                        //     var option = document.createElement("option")
                        //     option.text = (err);
                        //     option.value = (err);
                        //     x.add(option);
                    // for (let i = 0; i < err.split("\s").length; i++) {
                    // // let worktreeName = ((err.toString().split('\n'))[i].split("alicenode_inhabitat/")[1]);
                    // //if (err !== undefined) {	
                    //     console.log(err)
                    //     // for(var i = 0; i < options.length; i++) {
                    //     // options.foreach(function(element) {
                    //         var x = document.getElementById("userWorktree");
                    //         var option = document.createElement("option")
                    //         option.text = (err);
                    //         option.value = (err);
                    //         x.add(option);

                    //     // })


                    //  //   }  
                    // }
                        //populate the userWorkTree drop-down menu
                        // populateWorktreeMenu(arg)   
                        
                        
                        // var options = JSON.parse(arg);

                        break;

                    //populate the worktree drop-down with current list of worktrees
                    case "fps":
                        //document.getElementById('fps').innerHTML = arg;
                        break;
                        
                    case "branchname":  
                        // var steve = message.replace("currentBranch?", "")
                        
                        log("on branch " + arg);
                        currentBranch = arg;
                        break;
                    
                    case "Switched to Branch":
                        log(arg)
                        break;

                    case "currentVersion":
                        // editorCM.setValue(arg);
                        // fillEditor("a" + arg);

                        // orig1 = arg + value.replace(/\.\.\//g, "codemirror/").replace("yellow", "orange");
                        
                        //load current state into leftMergeview
                        value = arg
                        orig1 = arg
                        initUI();   
                        $( function() {
                            $( "#view" )
                        });                       
                        break;

                    case "show":
                        // fillEditor("b" + arg);
                        //TODO: alert ask to continue (will lose work if they continue without committing)
                        // if (isRightDirty){
                            //alert(whatever, but essentially an ok and cancel button)
                        //}
                        // orig1 = arg + value.replace(/\.\.\//g, "codemirror/").replace("yellow", "orange");
                        orig1 = arg;

                        initUI();
                        break;    
                    case "state":
                        //document.getElementById('state').innerHTML = arg;
                        break;
                    case "updateRepo":
                        log('Update Repo Graph')
                        break;
                    default:
                        log("cmd: " + cmd + ", " + arg);
                    }
        
                } else {
            
                log('received: ' + e.data);
                }
            }
        };
    ws.onerror = function() {
        log('error');
    };
}

function closeSocket() {
    log('closing');
    ws.close();
}

// keep checking socket status, re-open if closed:
setInterval(function(){
        if (!ws || ws.readyState === WebSocket.CLOSED) openSocket();
}, 2000);

//Git Graph
//clicking on a commit node sends the commit's hash to server
function getCommitDetail(evt) {
    selectedCommit = evt.target.id
    //console.log(evt.target.id)
    
    ws.send("git show " + selectedCommit);
    ws.send("getCurrentBranch");
    evt.target.setAttributeNS(null,"opacity","0.5");
}
//mouseover a commit node: change node's opacity
function mouseEnterCommit(evt) {
var details = document.getElementsByTagNameNS(evt.target, "title")[0]  

//place hovered commit details in a list onscreen
//console.log(details)
// evt.target.setAttributeNS(null,"opacity","0.5");
// var li = document.createElement('li');
// li.innerHTML = evt;
// var list = document.getElementById('commit_detail');
// list.insertBefore(li, list.childNodes[0]);

//console.log(evt.target.ref)
}

//get all commit nodes that contain the filename chosen by client, and highlight them in the svg
function highlightFileName(evt){
//TODO
}
//change commit node's colour opacity back to normal after mouseLeave
function mouseLeaveCommit(evt) {
    evt.target.setAttributeNS(null,"opacity","1");
}


//Get current content within CodeMirror's Left Mergeview
function sendLeftCode() {
    //TODO: figure out how to include the var 'authorName' in this
    //message, so that git will commit under this client's git username
    //i.e.  git commit --author="John Doe john@doe.org" -m "message"
    //also, if "guest" is selected, then make sure server just does a regular commit (no added author flag)
    //and email
    var commitMsg = prompt("Please provide a comment about your changes", "reticulating splines");
    //   var message = "edit?" + editorCM.getValue();   
    var changes = "edit?" + '?author' + authorName + " <" + authorEmail + ">?commit" + commitMsg + "?code" + dv.editor().getValue()
    log("Sent LeftEditor Contents to server: " + commitMsg);
    //log('sending: ' + message);
    ws.send(changes);
}
//Get current content within CodeMirror's Right Mergeview
function sendRightCode(val){
    if (val.includes("hash?")){

        thisHash = (val.replace("hash?", ""))
        console.log("Hash " + thisHash + " chosen")
    } 
    else {
    var message = "newbranch?" + dv.rightOriginal().getValue();
    console.log("SENDING TO SERVER: \n" + message)
    ws.send(message);
    selectedHash("this hash");
    }

}
//TODO: Do we still need this?
function sendText() {
    var message = document.getElementById('message').value;
    log('sending: ' + message);
    ws.send(message);
}

function sendBinary() {
    var message = decodeHexString(document.getElementById('message').value);
    log('sending binary: ' + encodeHexString(message));
    ws.send(new Uint8Array(message).buffer);
}
function decodeHexString(text) {
    if (text.search(/[^0-9a-f\s]/i) !== -1) {
        alert('Can\'t decode "' + text + '" as hexadecimal...');
    } else {
        text = text.replace(/\s/g, '');
        if (text.length % 2 === 1) {
            text = '0' + text;
        }
        var data = [];
        for (var i = 0, len = text.length; i < len; i += 2) {
            data.push(parseInt(text.substr(i, 2), 16));
        }
        //  return data;
    }
}
function encodeHexString(data) {
    var bytes = [];
    for (var i = 0, len = data.length; i < len; i++) {
        var value = data[i];
        bytes[i] = value.toString(16);
        if (value < 16) {
            bytes[i] = '0' + bytes[i];
        }
    }
    return bytes.join(' ');
}

//Client log
function log(message) {
    var li = document.createElement('li');
    li.innerHTML = message;
     var list = document.getElementById('messages');
     list.insertBefore(li, list.childNodes[0]);
}

if (sessionStorage.echoServer) {
    document.getElementById('server').value = sessionStorage.echoServer;
}

// function newBranch(){}
    
openSocket();


//having trouble with this, but also see the switch case about worktreeList
function populateWorktreeMenu(arg){
    // var select = document.getElementById('userWorktree')
    // select.options[select.options.length] = new  Option('Please Select...', 'Please Select...');
    // var options = JSON.parse(arg);
    // console.log("got it " + options )
    // for(var i = 0; i < options.length; i++) {
    // options.foreach(function(element) {
    //     var x = document.getElementById("userWorktree");
    //     var option = document.createElement("option")
    //     option.text = (element);
    //     option.value = (element);
    //     x.add(option);

    // })

        
    // var opt = options[i];
    // var el = document.createElement("option)")
    // el.textContent = opt;
    // el.value = opt;
    // select.appendChild(el);
// }


// $.get(arg, function(data) {
//     worktreeList = data
//     var lines = data.split('\n');
//     for(var line = 0; line < lines.length; line++){
//         var x = document.getElementById("userWorktree");
//         var option = document.createElement("option")
//         option.text = (lines[line]);
//         option.value = (lines[line]);
//         x.add(option);
//         }

// }, 'text');
}


function addWorktree(){

    //TODO add code for when user ADDS a new worktree

    var txt;
    var worktree = prompt("Please enter your worktree name", "(noSpacesPlease)");
    if (worktreeList.includes(worktree) == true){

    alert("provided worktree name already in use")

    } else {
        switch (worktree) {
            case null:
            case "":
            break;

            default: 
            var x = document.getElementById("userWorktree");
            var option = document.createElement("option")
            option.text = worktree;
            option.value = worktree;
            x.add(option);
            
            //set dropdown to new user worktree name
            var opts = x.options;
            for (var opt, j = 0; opt = opts[j]; j++) {
                if (opt.value == worktree) {
                    x.selectedIndex = j;
                    break;
                    }
                }
        
        //send the new worktree name over to server.js, and create the worktree dir    
        ws.send("addWorktree " + worktree)
        }
    }
}
//username selection (for git commits)
function userSelect()  { 
    
    selection = document.usernames.chooseUser.value;
    switch (selection) {

        case "Add User...":
        
        authorName = prompt("Enter your Full Name, as found in your github.com account", "Full Name");

        
        authorEmail = prompt("Enter the email address associated with your github account", "art@vandelay.com")

        
           
            //TODO: create a worktree for user with their username. replace all spaces with underscores. 
            ws.send("newUser?" + authorName + "$?$" + authorEmail)
            //console.log(userName, userEmail)

        //add new user to select in HTML, make sure its checked. 
        var select = document.getElementById('chooseUser');
        var length = select.length;
        var opt = document.createElement('option');
        opt.value = authorName;
        opt.innerHTML = authorName;
        select.appendChild(opt);
        document.getElementById('chooseUser').selectedIndex = (length);

        
        log("Working as git author " + authorName + " via " + authorEmail);
            
        break;

        default: log("Working as git author " + selection + " via " + userlist[selection]);
        authorName = selection;
        authorEmail = userlist[selection];
        ws.send("selectUser?" + selection);
        break;
    }

}


/////////////////////////////////////
                                    //MERGEVIEW
function toggleCollapse(){
    collapse = !collapse
    initUI(collapse)
}

function toggleDifferences() {
    dv.setShowDifferences(highlight = !highlight);
}

//get and set code in either of the MergeView editor panes
function initUI() {
    isRightDirty = false;

    if (value == null) return;
    var target = document.getElementById("view");
    target.innerHTML = "";
    dv = CodeMirror.MergeView(target, {
        value: value,
        // origLeft: panes == 3 ? orig1 : null,
        origRight: orig1,
        lineNumbers: true,
        mode: "clike",
        //highlightDifferences: "highlight",
        
        //NOTE: viewportMargin, when set to 'infinity', allows for full text searching, BUT seems to have been the source of the sluggishness in the client app!!
        viewportMargin: 10,
        revertButtons: true,
        allowEditingOriginals: true,
        autoRefresh: true,

        linewrapping: true,
        connect: "connect",
        theme: "icecode",
        collapseIdentical: true,
        // collapse: collapse
        

        
        /* init: */
        //place cursor in left editor at client init
        //autofocus: 1,

            //TODO: disable/enable editing in the codemirror instance. will use this once user worktrees are set up so that editing can only be enabled once a user worktree is chosen (or created). Once a worktree is chosen, change the readOnly value to false.
            //readOnly: "nocursor"
        //set tab index for editor
        // tabindex: 2,
        

        //editing
        undoDepth: 200,


        //cursor settings:
        cursorBlinkRate: 300,
        cursorScrollMargin: 0
    });

    //when new code loaded into right pane, reset isRightDirty flag   
    isRightDirty = false;

    //when user changes something in origRight, always create a new branch from this point in the history (new branch starting from previously chosen commit)
    dv.rightOriginal().on("changes", function(dv, changeObj){
        // && currentBranch == "master"
        console.log("editedRightCode" + authorName.split(' ').join('_') + '_' + selectedCommit + "_" + new Date().getTime() + " " + selectedCommit)
        if (isRightDirty == false) {
             ws.send("editedRightCode" + authorName.split(' ').join('_') + '_' + selectedCommit + "_" + new Date().getTime() + " " + selectedCommit)
 
        //    switch (currentBranch) {
        //         case "master":
        //         console.log("the current branch is MASTER")

        //         ws.send("newBranch" + thisHash);
        //         break;

        //         case (currentBranch !== "master"):
        //         console.log("The current branch is " + currentBranch)
        //         if (confirm("already on branch " + currentBranch + "This branch began from " + thisHash + "Create new?")) {
        //             // Save it!
        //         } 
        //         //alert("already on branch " + currentBranch + "\nstarted from " + thisHash + "create new?")
        //         break;


        }
   
        //  if (currentBranch == "master")
        //     {

        //         //TODO: then switch to new branch by sending this message to server + the currently selected commit hash

        //         // ws.send("newBranch" + thisHash);
        //     }
        // else {
        //             //TODO: alert user already on branch, ask if you want to switch to a new branch
        //     }

        isRightDirty = true;

    });


}

function mergeViewHeight(mergeView) {
    function editorHeight(editor) {
        if (!editor) return 0;
        return editor.getScrollInfo().height;
    }
    return Math.max(editorHeight(mergeView.leftOriginal()),
    editorHeight(mergeView.editor()),
    editorHeight(mergeView.rightOriginal()));
}

///////////////////////////////// BUILD THE REPO GRAPH //////////////////////////

// spacing of commits horizontally & vertically (maybe a svg scaling transform could be used instead??)
var rowsize = 20;
var colsize = 10;

// a way of mapping column to colour
function col_hue(col) {
    return col * 30;
}
// the main function, expects to receive a graph, of the form
// { roots:["hash", "hash", ...], commits:[obj, obj, ...], paths:[obj, obj, ...], maxcolumn: integer }
// returns the HTML code for an SVG representation of it
function make_svg_from_commits(graph) {

    var commits = graph.commits;
    var paths = graph.paths;
    var maxcolumn = graph.maxcolumn;
    
    // build a lookup-table from hash name to commit object:
    var commit_map = {};
    
    // build an array of svg elements:
    var svg = [];
    
    // compute required size of the svg canvas:
    var height = (commits.length + 2) * rowsize;
    var width = (maxcolumn + 1) * colsize;
    
    for (var i in commits) {
        let commit = commits[i];
        // build a lookup-table from hash name to commit object:
        commit_map[commit.hash] = commit;
        // annotate the commits with x, y positions:
        commit.x = commit.col * colsize;
        commit.y = commit.row * rowsize;
    }
    
    for (var i in paths) {
        var path = paths[i];
        // get the relevant commit objects:
        var from = commit_map[path.from];
        var to = commit_map[path.to];
        
        // start an SVG line segment
        var d = `M${from.x},${from.y}`;
        var hue = col_hue(from.col);
        // how we render the line depends on the relative columns of the two commits:
        if (to.col > from.col) {
            // new branch
            hue = col_hue(to.col);
            // append to SVG line segment command
            d += `L${to.x},${from.y + rowsize / 2}`;
        } else if (to.col < from.col) {
            // merge branch
            // append to SVG line segment command
            d += `L${from.x},${to.y - rowsize / 2}`;
        }
        // regular commit
        // append to SVG line segment command
        d += `L${to.x},${to.y}`;

        // store in our list of svg elements:
        svg.push(`<path id="path_${i}" d="${d}" stroke-width="1" fill="transparent"  style="stroke:hsl(${hue}, 100%, 30%);" />`);
    }
    
    for (var i in commits) {
        let commit = commits[i];
        // add a svg element for each commit:
        svg.push(`<circle id="${commit.hash}" cx="${commit.x}" cy="${commit.y}" r="4" style="fill:hsl(${col_hue(commit.col)}, 100%, 30%);" onmouseover="mouseEnterCommit(evt)" onmouseout="mouseLeaveCommit(evt)" onmousedown="getCommitDetail(evt)"><title>${commit.commit_date.join(", ")}\n${commit.committer_name.join(", ")}\n${commit.commit_files.join(", ")}\n${commit.commit_msg.join(", ")}\n${commit.ref.join(", ")}</title></circle>`);
    }

    // wrap the svg commands in an svg element, and return:
    return `<svg width=100% style="width:${width}; height:${height};" version="1.1" xmlns="http://www.w3.org/2000/svg">${svg.join("\n")}<g id="nodes"></svg>`;

}

</script>