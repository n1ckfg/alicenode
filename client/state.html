<!doctype html>
<html>
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1">
<title>Alicenode State Editor</title>

<head>
<!-- //TEMPORARY: just to aid in development workflow -->
<!-- <meta http-equiv="refresh" content="5; URL=http://localhost:8080"> -->
<!--        SOURCES         -->
<!-- Codemirror -->
    <!-- styles -->

    <link rel=stylesheet href="cm/docs.css">
    <link rel=stylesheet href="cm/codemirror.css">
    <link rel=stylesheet href="cm/addons/fullscreen/fullscreen.css">
    <link rel=stylesheet href="cm/one-dark.css">



    <!-- <link rel=stylesheet href="cm/merge.css">
    <link rel=stylesheet href="cm/icecoder.css"> -->

    <!-- scripts -->
    <script src="cm/codemirror.js"></script>
    <script src="cm/css.js"></script>
    <!-- load local server version if cdn unavailable -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script><script>if (!window.jQuery) document.write('<script src="cm/diff_match_patch.js"><\/script>');</script> -->

    <!-- <script src="cm/htmlmixed.js"></script> -->
    <!-- <script src="cm/xml.js"></script> -->
    <!-- <script src="cm/merge.js"></script> -->
    <!-- <script src="cm/modes/javascript.js"></script> -->
    <script src="cm/modes/clike.js"></script>
    <script src="cm/modes/glsl.js"></script>
      <script src="cm/addons/buttons/buttons.js"></script>
  <script src="cm/addons/panel.js"></script>
  <script src="cm/addons/fullscreen/fullscreen.js"></script>
  <script src="cm/cm-resize.js"></script>


<!-- General Sources -->
    <!-- style -->
    <link rel=stylesheet href="css/jquery-ui.css">

    <!-- <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css"> -->

    <link rel=stylesheet href="css/cards.css">
    <script src="js/jquery-3.3.1.js"></script>
    <script src="js/jquery-ui.js"></script>

    <!-- resizeable columns -->
    <link rel=stylesheet href="css/colresizeable.css">

    <script src="js/colResizable-1.5.min.js"></script>

    <script src="js/jquery.mousewheel.js"></script>

    <!-- server address & open/close -->

</head>

<style>

.cm-highlight {color: lightgreen; background-color: green}
.cm-highlight-lastLine {color: rgb(144, 182, 238); background-color: rgb(0, 102, 128)}
.CodeMirror-selection-highlight-scrollbar {background-color: green}

/* <!-- rgb(39, 174, 96)
rgb(142, 68, 173)
rgb(218, 247, 166)
rgb(255, 195, 0)
rgb(255, 87, 51)
rgb(199, 0, 57) --> */
/* .cm {
    width:200px;
   	margin:auto;
    font-size:14px;
    border:1px solid #000;
    border-collapse:collapse; }

.cm td {
    color:#000099;
    vertical-align:middle;
    text-align:left;
    border:1px solid #000;
    height: 100% } */

/* .stateParams {

} */
</style>

<!-- containing table -->
<table width="100%" height="100%">
    <tr  height="5%" >
        <th style="text-decoration: none">Alicenode State Editor</th>
        <th><input id="server" type="text" value="ws://localhost:8080" size="40">
            <button onclick="openSocket()">Open</button>
            <button onclick="closeSocket()">Close</button></th>
    </tr>

    <tr>
        <td>
            <button id="writeStateH">Save state.h</button>
            <button id="clearHighlights">Clear Highlighting</button>
            <button id="rebuildCPP2JSON">Rebuild cpp2json</button>

        </td>
        <td>

        </td>
    </tr>
    <tr>
        <td valign="top" height="90%">     
            <!-- table for the state.h code editor -->
            <table name="cm" display="inline-block" id="state.h" width="100%" border="0" cellpadding="0" cellspacing="0" >
                    <tr >
                        <th >state.h</th>
                    </tr>
                    <tr>
                        <td > 
                            <div id="stateh_source"></div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Notes: saving state.h also triggers a rebuild of cpp2json. This bootstraps an issue where cpp2json seems to only provide parameter names that were present at the most-recent build.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <script>document.domain = document.domain;
                            </script>
                            <!-- <iframe src="http://192.168.0.27:8081" width=100%>Windows Machine</iframe> -->
                            
                            <iframe src="http://192.168.0.27:8088/terminal" width=100% height=200px></iframe>
                        </td>
                    </tr>
                
            </table>
        </td>
        <td valign="top">
            <!-- table for the state.h parameters and values -->
            <table name="stateParams" overflow="scroll" id="stateValues" width="100%" border="0" cellpadding="0" cellspacing="0" display="inline-block";>
                <tbody>
                    <tr >
                        <th style="width: 40%;">Parameter</th>
                        <th style="width: 20%;">Type</th>
                        <th style="width: 40%;">Value</th>          
                    </tr>
                </tbody>
            </table>
        </td>
    </tr>

            </div>
        </td>
    </tr>

</table>

<script>
    
var cardIdArray = []; //store the list of card ID names
var value = "//new card" //default contents of a new card. can be replaced by a code fragment from the server

var count = 1; //count the number of cards generated, start at 1
var cardId = 1; //id for each new card div created

var bodySize = [document.body.clientWidth, document.body.clientHeight]
var ws_url;
var worktreeList;
var history;
var ws;
var ws_url = "ws://" + window.location.host;
//the alicenode state:
var state = [];
var lines = []
var lastLine;

var dv;

function log(msg){
  console.log(msg)
}
function updateState(paramName, paramValue){
    //update the state.bin server-side
    let stateUpdate = [];
    ws.send("stateUpdate?" + paramName + " " + paramValue)

    // get the begin-end lines of each parameter within the state.h!
    Object.keys(state).forEach(function(key, value) {
        pName = state[key].paramName;
        begin = state[key].begin - 1;
        end = state[key].end;
        
        //tell codemirror to highlight the chosen lines
        if (pName == paramName){
                // remember all the lines that have been highlighted
                lines.push({begin})
                // highlight previously modified parameter as blue in the state.h
                if (lastLine) {
                    dv.addLineClass(lastLine, 'background', 'cm-highlight-lastLine');
                }
                var t = dv.charCoords({line: begin, ch: 0}, "local").top; 
                var middleHeight = dv.getScrollerElement().offsetHeight / 2; 
                dv.scrollTo(null, t - middleHeight - 5); 
                dv.addLineClass(begin, 'background', 'cm-highlight');
                dv.setCursor({line: begin, ch: window.lastpo});

                // store the selected line for next time we change a param
                lastLine = begin;

            
            console.log(paramName, begin, end)
        }
    })
}

function sourceCard(stateCode) {
    // isRightDirty = false;
    if (value == null) return;
    var target = document.getElementById("stateh_source");
    target.innerHTML = "";
    dv = CodeMirror(target, {
        //position: "relative",
        value: stateCode,
        // origLeft: panes == 3 ? orig1 : null,
        // origRight: orig1,
        styleActiveLine: true,
        lineNumbers: true,
        mode: "clike",
        //highlightDifferences: "highlight",
        theme: 'one-dark',
        readOnly: false,
        //NOTE: viewportMargin, when set to 'infinity', allows for full text searching, BUT when set to a high number seems to have been the source of the sluggishness in the client app!! so now its only at 10. 
        viewportMargin: 10,
        revertButtons: true,
        allowEditingOriginals: true,
        // autoRefresh: true,
        // showDifferences: true,
        lineWrapping: true,
        //editing
        undoDepth: 200,
        //cursor settings:
        cursorBlinkRate: 300,
        cursorScrollMargin: 0,  
        autofocus: true                 
    });
    dv.setSize("100%", 550);

}


// $('.param').click(function() {
//   console.log($(this).attr('value'));
// });
// <!-- 
// $(document).click(function(event) {
//     var text = $(event.target).text();
//     console.log(text)
// });

// $(document).click(function(event) {
//     console.log($(event.target).text());
// }); -->
document.getElementById('server').value = ws_url;

function openSocket() {
    
    var url = document.getElementById('server').value;
    ws = new WebSocket(ws_url);
    ws.binaryType = 'arraybuffer';
    ws.onopen = function() {
        // tell the server to send the most-recent state
        ws.send("stateEditorConnect?")
        // log('open');  
        // ws.send("client_SVG?")

        // ws.send("getCurrentBranch")
        
        // //temporary: for now set user as Guest so I don't have to keep choosing user while developing. 
        // ws.send("selectUser?" + "Guest");
        
        sessionStorage.echoServer = url;
    };
    ws.onclose = function() {
        // log('close');
    };
    ws.onmessage = function(e) {
        /*if (e.data instanceof Blob) {
            var reader = new FileReader();
            reader.onload = function(e) {
                log('received blob: ' + encodeHexString(new Uint8Array(e.target.result)));
            };
            reader.readAsArrayBuffer(e.data);
        } else */
        if (e.data instanceof ArrayBuffer) {
            //log(encodeHexString(new Uint8Array(e.data)));
            //log("received arraybuffer size: " + e.data.byteLength + " bytes");
            
            let s = "";
            let fv = new Float32Array(e.data);
            for (var i = 0; i < fv.length; i+=3) {
                s += "<li>" + (i/3 + ": { " + fv[i] + ", " + fv[i+1] + ", " + fv[i+2] + " }</li>");
            }
            
            // document.getElementById('state').innerHTML = s;     
            
        } else {
            let message = e.data;
            let q = message.indexOf("?");
            if (q > 0) {
                let cmd = message.substring(0, q);
                let arg = message.substring(q+1);
                switch(cmd) {

                                        //////////////
                    //filter out known messages bound for the other pages:
                    case "src":
                    case "deck":
                    break;
                    //////////////
                    
                    //if the ast parser or mmap retrieval reports errors or warnings:
                    case "serverWarnings": 
                    var li = document.createElement('li');
                    var list = document.getElementById('serverWarnings');

                    li.innerHTML = (arg);
                    list.appendChild(li);

                    var serverWarnings = document.querySelector('#serverWarnings');
                    break;


                    case "state.h":
                    stateCode = JSON.parse(arg)
                    //note, we may not pass the state using state.h, but instead could just regen it from the ast received by the next case statement below, aka 'state'
                    sourceCard(stateCode)
                    //get and set code in the new card
                    break;
                    
                    case "state":
                    //we need to clear the table rows (except for the first, since [1]in order to add after last we need something there already, annnnd the 0th table row is our table header!)
                    
                    $("#stateValues").find("tr:gt(0)").remove();
                    
                    //console.log(arg)

                    
                    
                    state = (JSON.parse(arg))
                    console.log(state)
                    let offset;
                    let type;
                    let pName;
                    let pValue;
                    let start;
                    let end;
                    let begin;
                    let endChar;
                    let endCol;


                    Object.keys(state).forEach(function(key, value) {
                        //console.log(state[key].paramName)
                        pName;
                        
                         type = state[key].type;
                         pName = state[key].paramName;
                         pValue = state[key].paramValue;
                         begin = state[key].begin;
                         end = state[key].end;
                         endChar = state[key].endChar;
                         endCol = state[key].endCol;
                         offset = state[key].offset;

                        //different types will require different ui elements.
                            switch (type) {
                                
                                // a float or an int will use the jquery spinner
                                case "float":
                                case "int":
                                case "double":
                                // 
                                // $('#stateParams tr').click(function(){
                                //     $(this).remove();
                                //     return false;
                                //});
                                $('#stateValues tr:last').after('<tr id=\"row_' + pName + '\"><td>' + pName + '</td><td><h3>' + type + '</h3></td><td>' + '<input id=\"' + pName + '\" class="param" onchange="updateState(this)" value=\"' + pValue + '\"></input>' + '</td></tr>');
                                // turn the input element into a jquery spinner
                                $("#" + pName).spinner({
                                    step: 0.1,
                                });
                                // have the spinner report its value whenever it gets changed by mouse or keyboard events.
                                $( "#" + pName ).spinner({spin: function( event, ui, id ) {
                                    console.log(event)
                                    console.log(ui)
                                    console.log(id)
                                    updateState(this.id, ui.value);
                                    }
                                });

                                $('#' + pName).on("keyup",function(event){
                                    
                                    console.log(event.target.value)
                                    console.log(event.target.id)
                                    if(event.keyCode == 13){ 
                                         event.stopImmediatePropogation();
                                         event.preventDefault();
                                    }
                                    updateState(event.target.id, event.target.value);
                                });

                                $().data('mmapData', { offset: offset })
                                $("#" + pName).width(100);


                                break;


                                
                                // for params whose type we haven't yet figure out how to retrieve
                                default:

                                    //TEMPORARY:

                                    pValue = type


                                    $('#stateValues tr:last').after('<tr id=\"row_' + pName + '\"><td>' + pName + '</td><td>' + '<input type=text id=\"' + pName + '\" class="param" onchange="updateState(this)" value=\"' + pValue + '\"></input>' + '</td></tr>');
                                        //these are arrays, so we cant just put them into a spinner ui.

                                        // turn the input element into a jquery spinner
                                        // $("#" + pName).spinner({
                                        //     step: 0.1,
                                        // });
                                    // have the input report its value whenever it gets changed by mouse or keyboard events.
                                    $( "#" + pName ).on("change paste keyup", function( event, ui, id ) {
                                        updateState(this.id, ui.value);
                                        }
                                    );

                                    $().data('mmapData', { offset: offset })

                                    $("#" + pName).width(200);

                                // var li = document.createElement('li');
                                // var list = document.getElementById('otherParams');

                                // li.innerHTML = ("Parameter: " + pName + " Type: " + type);
                                // list.appendChild(li);

                                // var chatMessages = document.querySelector('#otherParams');
                                // chatMessages.scrollTop = chatMessages.scrollHeight - chatMessages.clientHeight;
                                break;

                            case "unusedParams":
                            console.log("parameter types found but not used: " + arg)

                                break;
                            }

                        // }
                    })




                    default:

                    break;

                    }
        
                } else {
            
                log('received: ' + e.data);
                }
            }
        };
    ws.onerror = function() {
        log('error');
    };
}

function closeSocket() {
    log('closing');
    ws.close();
}

// keep checking socket status, re-open if closed:
setInterval(function(){
        if (!ws || ws.readyState === WebSocket.CLOSED) openSocket();
}, 2000);


// write new state.h to disk and commit changes
$(function() {
    $("#writeStateH").click( function()
        {
            //console.log(line)
        writeStateH = {};

        authorName = "Graham Wakefield"
        authorEmail = "grrrwaaa@gmail.com"
        newState = dv.getValue()

        var commitMsg = prompt('Please provide a comment about your changes', 'reticulating splines')
        writeStateH = {authorName, authorEmail, newState, commitMsg}
        ws.send('state.h_write?' + JSON.stringify(writeStateH))
        console.log(writeStateH)
        // tell server to rebuild cpp2json in case param names were added/removed/changed to state.h
        ws.send("rebuildCpp2json?")
          
    });
});


//// clear highlights
$(function() {
    $("#clearHighlights").click( function()
        {
        Object.keys(lines).forEach(function(key, value) {
        console.log(lines[key].begin)
        dv.removeLineClass(lines[key].begin, 'background');

        });
    });

})

//// trigger manual rebuild of cpp2json
$(function() {
    $("#rebuildCPP2JSON").click( function()
        {
            ws.send("rebuildCpp2json?")
    });

})
rebuildCPP2JSON

var EventUtil = {

addHandler: function(element, type, handler){
    if (element.addEventListener){
        element.addEventListener(type, handler, false);
    } else if (element.attachEvent){
        element.attachEvent("on" + type, handler);
    } else {
        element["on" + type] = handler;
    }
},

removeHandler: function(element, type, handler){
    if (element.removeEventListener){
        element.removeEventListener(type, handler, false);
    } else if (element.detachEvent){
        element.detachEvent("on" + type, handler);
    } else {
        element["on" + type] = null;
    }
},

getEvent: function(event) {
    return event ? event : window.event;
},

getTarget: function(event) {
    return event.target || event.srcElement;    
},

getWheelDelta: function(event) {
    if (event.wheelDelta){
        return event.wheelDelta;
    } else {
        return -event.detail * 40;
    }
},

preventDefault: function(event) {
    if (event.preventDefault){
        event.preventDefault();
    } else {
        event.returnValue = false;
    }
}

};

var curElem;
function onWheel(event) {
curElem = EventUtil.getTarget(event);
event = EventUtil.getEvent(event);
var curValInt = parseInt(curElem.innerHTML);
var curValFloat = parseFloat(curElem.innerHTML);
var delta = EventUtil.getWheelDelta(event);

var scrollType = getLineData(event);

  switch (scrollType) {
                                
    case "float":
        if (delta > 0) {
            curElem.innerHTML = curValFloat + 0.01 +"f";
            getLineData(event);
        } else{ 
            curElem.innerHTML = curValFloat - 0.01+"f";
            getLineData(event);
        }
        break;
    case "int":
    if (delta > 0) {
            curElem.innerHTML = curValInt + 1;
            getLineData(event);
        } else{ 
            curElem.innerHTML = curValInt - 1;
            getLineData(event);
        }
        break;
    case "double":
    case "default":
        if (delta > 0) {
            curElem.innerHTML = curValInt + 1;
            getLineData(event);
        } else{ 
            curElem.innerHTML = curValInt - 1;
            getLineData(event);
        }
        break;
  }


EventUtil.preventDefault(event);

}

var cursorY;
var cursorX;

$(function() {

$("#stateh_source").on("mouseover", function (){
    $(".cm-number").hover(function(event){
        EventUtil.addHandler(document,'mousewheel', onWheel);
        EventUtil.addHandler(document,'DOMMouseScroll', onWheel);
        
        $(".cm-number").filter(EventUtil.getTarget(event)).css("background-color", "mediumblue");

         var $this = $(this),
        scrollTop = this.scrollTop,
        scrollHeight = this.scrollHeight,
        height = $this.height(),
        delta = (event.type == 'DOMMouseScroll' ?
            event.originalEvent.detail * -40 :
            event.originalEvent.wheelDelta),
        up = delta > 0;

    var prevent = function() {
        event.stopPropagation();
        event.preventDefault();
        event.returnValue = false;
        return false;
    }

    if (!up && -delta > scrollHeight - height - scrollTop) {
        // Scrolling down, but this will take us past the bottom.
        $this.scrollTop(scrollHeight);
        return prevent();
    } else if (up && delta > scrollTop) {
        // Scrolling up, but this will take us past the top.
        $this.scrollTop(0);
        return prevent();
    }

    },
    function(){
            EventUtil.removeHandler(document, 'mousewheel', onWheel);
            EventUtil.removeHandler(document, 'DOMMouseScroll', onWheel);

            $(".cm-number").filter(EventUtil.getTarget(event)).removeAttr("style");
        });
    });
});


function getLineData(event){
    var cursorX = event.pageX;
    var cursorY = event.pageY;

    var scrollData = dv.coordsChar({ left: cursorX, top: cursorY });
    scrollData.line = scrollData.line + 1;

    for(var i = 0; i < state.length; i++){

            if(scrollData.line == state[i].begin){
                //console.log("object?" + scrollData.line + " stateNumber:" + state[i].begin)

                var correctObject = state[i];

                if(state[i].type == "float"){
                    
                    var slice = curElem.innerHTML;
                    curElem.innerHTML = slice = parseFloat(slice).toFixed(2);
                    curElem.innerHTML = curElem.innerHTML.toString() + "f";
                    slice.toString();
                    slice.substring(0, slice.length - 1);
                    parseFloat(slice);


                    ws.send("stateUpdate?" + correctObject.paramName + " " + slice)
                    document.getElementById(correctObject.paramName).value= slice;
                } else{
                    ws.send("stateUpdate?" + correctObject.paramName + " " + curElem.innerHTML)
                    document.getElementById(correctObject.paramName).value=curElem.innerHTML;
                // console.log(correctObject.paramName + " value: " + curElem.innerHTML)
                }


               return state[i].type;
            }

        }
    

}
</script>


</body>
</html>