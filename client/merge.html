<!doctype html>

<title>Alicenode: Client</title>
<meta charset="utf-8"/>

<!-- Codemirror -->
<link rel=stylesheet href="cm/docs.css">
<link rel=stylesheet href="cm/codemirror.css">
<link rel=stylesheet href="cm/merge.css">
<link rel=stylesheet href="cm/icecoder.css">
<script src="cm/codemirror.js"></script>
<!-- <script src="/cm/xml.js"></script> -->
<script src="cm/css.js"></script>
<script src="js/diff_match_patch.js"></script>
<script src="cm/merge.js"></script>
<script src="cm/modes/javascript.js"></script>
<script src="cm/modes/clike.js"></script>
<script src="cm/modes/glsl.js"></script>
<script type="text/javascript" src="js/diff_match_patch.js"></script>

<!--script sources for the repo_graph & jquery -->
<script type="text/javascript" src="js/jquery.2.1.3.min.js"></script>
<script type="text/javascript" src="js/jquery.mousewheel.min.js"></script>
<script type="text/javascript" src="js/jquery.color.js"></script>
<script type="text/javascript" src="js/bootstrap.min.js"></script>
<script type="text/javascript" src="js/jquery.graphviz.svg.js"></script>

<!-- temp fix for the 'cannot find 'favicon.ico' error -->
<link rel="shortcut icon" href="">




<style>
    .CodeMirror { line-height: 1 }
    @media screen and (min-width: 1300px) {
      /* article { max-width: 50%; } */
      #nav { border-right: 499px solid transparent; }
    }
    
    html { width:100%;height:100%; margin:0;padding: 0 }
    body { width:100%;height:100%; margin:0;padding: 0 }
    /* svg, #gitgraph { width:100%;height:100%; margin:0;padding: 0 }  */
    /* div {  display: inline-block } */

/* <div id="container">
        <div id="view"></div>
        <div id="gitgraph"></div>
    </section> */
 #serverMessages {
     position: fixed;
     bottom: 0;
     left: 0;
     width: 50%;
     

 }
 #container {
     width: 100%; 
     height: 500px;
     /* margin: 0 auto; */
     /* overflow: scroll; */
 }
 #view, #gitgraph {
     float: left;
     height: 500px;
     /* min-height: 100%; */
 }
 #view {
     width: 80%;
 }

#gitgraph, #svg {
    width: 20%;
    margin: 0;
    padding: 0;
    overflow: scroll;
    background-color: lightblue;

}
</style>

    <input id="server" type="text" value="ws://localhost:8080" size="40">
    <button onclick="openSocket()">Open</button>
    <button onclick="closeSocket()">Close</button>
</p>



<!-- drop down list of available worktrees or make a new worktree -->
<form name="aform"> Current User Worktree: 
    <select id="userWorktree" onchange="worktreeSelect();">
            <option selected disabled>Please Select Worktree</option> 
            <!-- <option value="?makeNewWorktree">New Worktree... (unready)</option>  -->
    </select>    
    </form>
    <button id="addWorktree" onclick="addWorktree()">Create New Worktree</button> 
    <br>


    <!-- <select id="example"></select> -->

Editor Settings
<button id="live_diffing" onclick="toggleDifferences()">Toggle: Live Diffing</button> 
<button id="toggleCollapse" onclick="collapse">Toggle: Collapse Changes</button> 
<button id="align" onclick="connect = connect ? null : 'align'; initUI()">Toggle: Align Changes</button> 
</p>
<button onclick="sendLeftCode()">Send Left Code</button>
<button onclick="sendCodeRelay()">Send Right Code</button>


<button onclick="loadSVG()">Reload SVG</button>


<!-- the Codemirror mergeview instance! -->



<div id="container">
        <div id="view"></div>
        <div id="gitgraph"></div>

        
    </section>
    </div>
<p>


<!--the older repository graph -->
<!-- <div id="graph" style="width: 100%; height: 20%; overflow: scroll; position: fixed; zoom: 50%"></div> -->

<!-- mouseover stuff -->
<!-- <h3 id="commit_detail"></h3> -->

<!-- server messages -->
<div id="serverMessages">
<ul id="messages"></ul>
</div>

<script>

//globals
var currentBranch;
var thisHash;
var currentWorktree
var ws_url;
var worktreeList;
 var history;
 //var col;


//send the code from right pane
function sendCodeRelay(){

    sendRightCode("a")
}

var ws_url = "ws://" + window.location.host;

document.getElementById('server').value = ws_url;

var ws;
function openSocket() {
    log('opening');
    var url = document.getElementById('server').value;
    ws = new WebSocket(ws_url);
    ws.binaryType = 'arraybuffer';
    ws.onopen = function() {
        loadSVG();
        // log('open');  
        ws.send("client_SVG?")

        ws.send("getCurrentBranch")
        sessionStorage.echoServer = url;
    };
    ws.onclose = function() {
        // log('close');
    };
    ws.onmessage = function(e) {
        /*if (e.data instanceof Blob) {
            var reader = new FileReader();
            reader.onload = function(e) {
                log('received blob: ' + encodeHexString(new Uint8Array(e.target.result)));
            };
            reader.readAsArrayBuffer(e.data);
        } else */
        if (e.data instanceof ArrayBuffer) {
            //log(encodeHexString(new Uint8Array(e.data)));
            //log("received arraybuffer size: " + e.data.byteLength + " bytes");
            
            let s = "";
            let fv = new Float32Array(e.data);
            for (var i = 0; i < fv.length; i+=3) {
                s += "<li>" + (i/3 + ": { " + fv[i] + ", " + fv[i+1] + ", " + fv[i+2] + " }</li>");
            }
            
            // document.getElementById('state').innerHTML = s;
            
            
        } else {
            let message = e.data;
            let q = message.indexOf("?");
            if (q > 0) {
                let cmd = message.substring(0, q);
                let arg = message.substring(q+1);
                switch(cmd) {
                
                
                //svg from server:
                case "gitLog":
                let gitlog = arg;
                var svg = make_svg_from_gitlog(gitlog);
                $("#gitgraph").html(svg);
                //console.log(svg)


                    //console.log(history)
                //function passGitLog(history) {
                 //let gitlog = "test";
                // testThis(history);
                //make_svg_from_gitlog(history);
                //console.log(history)

                //}
                break;

               // case worktreeList:

                    //populate the worktree drop-down with current list of worktrees
                case "fps":
                //	document.getElementById('fps').innerHTML = arg;
                    break;
                    
                case "branchname":  
                    // var steve = message.replace("currentBranch?", "")
                    
                    log("on branch " + arg);
                    currentBranch = arg;
                    break;
                
                case "Switched to Branch":
                    log(arg)
                    break;

                case "edit":
                    // editorCM.setValue(arg);
                    // fillEditor("a" + arg);

                    // orig1 = arg + value.replace(/\.\.\//g, "codemirror/").replace("yellow", "orange");
                    value = arg
                    orig1 = arg
                    initUI();                          
                    break;
                //
                case "show":
                    // fillEditor("b" + arg);

                    //TODO: alert ask to continue (will lose work if they continue without committing)
                    // if (isRightDirty){
                        //alert(whatever, but essentially an ok and cancel button)
                    //}
                    // orig1 = arg + value.replace(/\.\.\//g, "codemirror/").replace("yellow", "orange");
                    orig1 = arg;

                    initUI();
                    break;    
                case "state":
                    //document.getElementById('state').innerHTML = arg;
                    break;
                case "updateRepo":
                    loadSVG();
                    log('Update Repo Graph')
                    break;
                default:
                    log("cmd: " + cmd + ", " + arg);
                }
        
            } else {
            
                log('received: ' + e.data);
            }
        }
    };
    ws.onerror = function() {
        log('error');
    };
}
function closeSocket() {
    log('closing');
    ws.close();
}

// keep checking socket status, re-open if closed:
setInterval(function(){
        if (!ws || ws.readyState === WebSocket.CLOSED) openSocket();
}, 2000);


//Get current content within ComeMirror's Left and Right Mergeview
function sendLeftCode() {
    //   var message = "edit?" + editorCM.getValue();   
    var message = "edit?" + dv.editor().getValue()
    console.log("SENDING TO SERVER: \n" + message);
    //log('sending: ' + message);
    ws.send(message);
}

function sendRightCode(val){
    if (val.includes("hash?")){

        thisHash = (val.replace("hash?", ""))
        console.log("Hash " + thisHash + " chosen")
    } 
    else {
    var message = "newbranch?" + dv.rightOriginal().getValue();
    console.log("SENDING TO SERVER: \n" + message)
    ws.send(message);
    selectedHash("this hash");
    }

}
function sendText() {
    var message = document.getElementById('message').value;
    log('sending: ' + message);
    ws.send(message);
}


function sendBinary() {
    var message = decodeHexString(document.getElementById('message').value);
    log('sending binary: ' + encodeHexString(message));
    ws.send(new Uint8Array(message).buffer);
}
function decodeHexString(text) {
    if (text.search(/[^0-9a-f\s]/i) !== -1) {
        alert('Can\'t decode "' + text + '" as hexadecimal...');
    } else {
        text = text.replace(/\s/g, '');
        if (text.length % 2 === 1) {
            text = '0' + text;
        }
        var data = [];
        for (var i = 0, len = text.length; i < len; i += 2) {
            data.push(parseInt(text.substr(i, 2), 16));
        }
        //  return data;
    }
}
function encodeHexString(data) {
    var bytes = [];
    for (var i = 0, len = data.length; i < len; i++) {
        var value = data[i];
        bytes[i] = value.toString(16);
        if (value < 16) {
            bytes[i] = '0' + bytes[i];
        }
    }
    return bytes.join(' ');
}
function log(message) {
    var li = document.createElement('li');
    li.innerHTML = message;
    document.getElementById('messages').appendChild(li);
}
if (sessionStorage.echoServer) {
    document.getElementById('server').value = sessionStorage.echoServer;
}

function newBranch(){}
openSocket();


//populate the userWorkTree drop-down menu
var select = document.getElementById('selectElementId')
// select.options[select.options.length] = new  Option('Please Select...', 'Please Select...');
$.get('worktreeList.txt', function(data) {
    worktreeList = data
    var lines = data.split('\n');
    for(var line = 0; line < lines.length; line++){
        var x = document.getElementById("userWorktree");
        var option = document.createElement("option")
        option.text = (lines[line]);
        option.value = (lines[line]);
        x.add(option);
        }


}, 'text');

function addWorktree(){

    //TODO add code for when user ADDS a new worktree



        var txt;
        var worktree = prompt("Please entre your worktree name", "(noSpacesPlease)");
        if (worktreeList.includes(worktree) == true){

        alert("provided worktree name already in use")

        } else {
        switch (worktree) {
                case null:
                case "":
                break;

                default: 
        var x = document.getElementById("userWorktree");
        var option = document.createElement("option")
        option.text = worktree;
        option.value = worktree;
        x.add(option);
        
        //set dropdown to new user worktree name
            var opts = x.options;
            for (var opt, j = 0; opt = opts[j]; j++) {
                if (opt.value == worktree) {
                x.selectedIndex = j;
                break;
                }
            }
            
        //send the new worktree name over to server.js, and create the worktree dir    
        ws.send("addWorktree " + worktree)
}

}
}

// worktree selection 
function worktreeSelect()  { 
    
    selection = document.aform.userWorktree.value;

        //switch to an existing worktree
        log("Right editor working within " + selection + "'s worktree")
        ws.send("switchWorktree " + selection)
    }

//tell git to revert to master commit HEAD
//function revertMaster() {
   // ws.send("git return to master");
   // }

// $(document).ready(function(){
//     loadSVG();

// });



function make_svg_from_gitlog(gitlog) {
//let col;    
    let rowsize = 20;
    let colsize = 10;

        function col_hue(col) { return col*30; }

    let lines = gitlog.split("\n");
    let commit_list = [];
    let commit_map = {};
    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].split("|");
        let commit = {
        hash: line[0],
        children: line[1] ? line[1].split(" ") : [],
        ref: line[2] ? line[2].split(", ") : [],
        row: i+1
        };
        commit_list.push(commit);
        commit_map[commit.hash] = commit;
    }
    // depth first traversal
    // to assign columns to each commit
    // and also generate the paths as we go
    let first_commit = commit_list[0];
    first_commit.col = 1;
    let stack = [  first_commit ];
    let visited = {};
    let paths = [];
    while (stack.length > 0) {
        let parent = stack.pop();
        visited[parent.hash] = true;
        parent.x = parent.col * colsize;
        parent.y = parent.row * rowsize;
        
        // add children to stack:
        for (let i=parent.children.length-1; i>=0; i--) {
        let child_hash = parent.children[i];
        let child = commit_map[parent.children[i]];
        //console.log(commit_map)
        if (!visited[child_hash]) {      
            child.col = (parent.col + i);
            stack.push(child);
        }
        // add a path:
        paths.push({
            from: parent,
            to: child
        });
        }
    }

    let svg = ['<svg width=100% height=100% version="1.1" xmlns="http://www.w3.org/2000/svg">'];

    for (let i in commit_list) {
        let commit = commit_list[i];
            if (!commit.x){
                //if the initial commit runs throught the script as a child, it breaks
                console.log("initial commit reached")
            } else {
            svg.push(`<circle id="${commit.hash}" cx="${commit.x}" cy="${commit.y}" r="4" style="fill:hsl(${col_hue(commit.col)}, 100%, 30%);" />`); 
            }
    }

    for (let i in paths) {
        let path = paths[i];
        let from = path.from;
        let to = path.to;

        let d = `M${from.x},${from.y}`;
        let hue = col_hue(from.col);
        if (to.col > from.col) {
        // new branch
        hue = col_hue(to.col);
        let branch = {
            x: to.x,
            y: from.y + rowsize/2
        }
        d += `L${branch.x},${branch.y}`;

        } else if (to.col < from.col) {
        // merge branch
        let branch = {
            x: from.x,
            y: to.y - rowsize/2
        }
        d += `L${branch.x},${branch.y}`;
        } 
        // regular commit
        d += `L${to.x},${to.y}`;

        svg.push(`<path id="path_${i}" d="${d}" stroke-width="1" fill="transparent"  style="stroke:hsl(${hue}, 100%, 30%);" />`); 

    }


    svg.push("</svg>");
    svg = svg.join("\n");
    return svg;

}

//$("#gitgraph").html(svg);

// testSVG();
// console.log("ho hum")

//make_svg_from_gitlog(gitlog);

// let gitlog = 


//load the repo graph svg
function loadSVG(){
// $(document).ready(function(){
// $("#graph").graphviz({
//     url: "repo_graph.svg?" + new Date().getTime(),
//     shrink: "0", 
//     // tooltips: "init, update, show",
//     //highlight: "selected",
//     ready: function() {
//         var gv = this
//         //console.log(gv.nodesByName());

//         //gv.tooltip($elements, show);
//         //console.log(gv.highlight());

//         gv.nodes().click(function () {
//             var $set = $()
//             $set.push(this)
//             $set = $set.add(gv.linkedFrom(this, true))
//             $set = $set.add(gv.linkedTo(this, true))
//             gv.highlight($set, true)

//             ws.send("git show " + $(this).attr("data-name"));
//             ws.send("getCurrentBranch");

//             sendRightCode("hash?" + $(this).attr("data-name"));

//         })


        
//         // gv.nodes().mouseenter(function () {
//         //     var $set = $()
//         //     $set.push(this)
//         //     $set = $set.add(gv.linkedFrom(this, true))
//         //     $set = $set.add(gv.linkedTo(this, true))
//         //     gv.highlight(selected, true)
//         //     console.log($(this).attr("data-name"));


//         // })


//         //mouseover a digraph node: reveal its commit hash
//         //   gv.nodes().mouseenter(function(){
            
//             //   gv.highlight(selected, true)
//         //     var hash = ($(this).attr("data-name"));
//             //var hashData = ($.getJSON('log.json', function(data) {
//                 //   var details = ($(data).attr(this));

//                 //var details = data[hash];
//         //    commit_detail.innerText = hash;
//         //       ws.send("hash" + hash);
//                 // console.log(details);

//             // }))
//                 //console.log($(this).attr("data-name"));
//                 //  commit_detail.innerText = hash;
//                 // ws.send("hash" + hash);
//                 //  console.log(this)
//                 // })
//     }
// });
// //});

}    



/////////////////////////////////////
                                    //MERGEVIEW

var value;
var orig1;
var dv;
panes = 2;
highlight = true;
connect = "align";
var target;
var collapse;
var requested;
var current;
var isRightDirty = false;
var currentBranch;

function toggleCollapse(){
    collapse = !collapse
    initUI()
}

function toggleDifferences() {
  dv.setShowDifferences(highlight = !highlight);
}

//get and set code in either of the MergeView editor panes
function initUI() {
 
    if (value == null) return;
    var target = document.getElementById("view");
    target.innerHTML = "";
        dv = CodeMirror.MergeView(target, {
            value: value,
            // origLeft: panes == 3 ? orig1 : null,
            origRight: orig1,
            lineNumbers: true,
            mode: "clike",
            highlightDifferences: "highlight",
            viewportMargin: Infinity,
            revertButtons: true,
            allowEditingOriginals: true,
            autoRefresh: true,

            linewrapping: true,
            connect: "align",
            theme: "icecode",
            //collapseIdentical: collapse
            collapse: collapse
        });
    //when new code loaded into right pane, reset isRightDirty flag   
    isRightDirty = false;

    //when user changes something in origRight, check if on master, if so, create and checkout a new branch
    dv.rightOriginal().on("changes", function(dv, changeObj){
        
        if (isRightDirty == false && currentBranch == "master") {
            ws.send("createNewBranch " + thisHash)
        //    switch (currentBranch) {
        //         case "master":
        //         console.log("the current branch is MASTER")

        //         ws.send("newBranch" + thisHash);
        //         break;

        //         case (currentBranch !== "master"):
        //         console.log("The current branch is " + currentBranch)
        //         if (confirm("already on branch " + currentBranch + "This branch began from " + thisHash + "Create new?")) {
        //             // Save it!
        //         } 
        //         //alert("already on branch " + currentBranch + "\nstarted from " + thisHash + "create new?")
        //         break;


        }

            
        
        
            
          //  if (currentBranch == "master")
        //     {

        //         //TODO: then switch to new branch by sending this message to server + the currently selected commit hash

        //         // ws.send("newBranch" + thisHash);
        //     }
        // else {
        //             //TODO: alert user already on branch, ask if you want to switch to a new branch
        //     }

        
        isRightDirty = true;

    });


}

//pretty sure this is deprecated?
// // prepare the codemirror instance
// window.onload = function() {
//     let d = document.createElement("div"); d.style.cssText = "width: 50px; margin: 7px; height: 14px"; dv.editor().addLineWidget(57, d)
// };

function mergeViewHeight(mergeView) {
  function editorHeight(editor) {
    if (!editor) return 0;
    return editor.getScrollInfo().height;
  }
  return Math.max(editorHeight(mergeView.leftOriginal()),
                  editorHeight(mergeView.editor()),
                  editorHeight(mergeView.rightOriginal()));
}

// function resize(mergeView) {
//   var height = mergeViewHeight(mergeView);
//   for(;;) {
//     if (mergeView.leftOriginal())
//       mergeView.leftOriginal().setSize(null, height);
//     mergeView.editor().setSize(null, height);
//     if (mergeView.rightOriginal())
//       mergeView.rightOriginal().setSize(null, height);

//     var newHeight = mergeViewHeight(mergeView);
//     if (newHeight >= height) break;
//     else height = newHeight;
//   }
//   mergeView.wrap.style.height = height + "px";
// }
</script>
</article>
